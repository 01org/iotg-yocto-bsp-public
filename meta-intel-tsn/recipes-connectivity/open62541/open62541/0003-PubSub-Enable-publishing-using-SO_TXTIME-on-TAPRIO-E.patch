From 5d3f775f9f25f88fe4b79f29c987861447bac663 Mon Sep 17 00:00:00 2001
From: "Wong, Vincent Por Yin" <vincent.por.yin.wong@intel.com>
Date: Tue, 11 Dec 2018 10:30:53 +0800
Subject: [PATCH 3/4] PubSub: Enable publishing using SO_TXTIME on TAPRIO & ETF
 qdiscs

Signed-off-by: Wong, Vincent Por Yin <vincent.por.yin.wong@intel.com>
---
 CMakeLists.txt                            |   8 ++
 examples/pubsub/tutorial_pubsub_publish.c | 131 +++++++++++++++++++++-
 include/ua_config.h.in                    |   1 +
 include/ua_plugin_pubsub.h                |   2 +
 include/ua_server_pubsub.h                |   9 ++
 plugins/ua_network_pubsub_ethernet.c      | 120 +++++++++++++++++++-
 src/pubsub/ua_pubsub.c                    |  38 +++++++
 src/server/ua_server.c                    |   1 +
 src/ua_timer.c                            |   6 +-
 9 files changed, 312 insertions(+), 4 deletions(-)

diff --git a/CMakeLists.txt b/CMakeLists.txt
index 04b484a9..98cee256 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -206,6 +206,14 @@ if(UA_ENABLE_PUBSUB_INFORMATIONMODEL)
     endif()
 endif()
 
+option(UA_ENABLE_PUBSUB_SOTXTIME
+       "Use a custom UA_SEND() implementation for the publisher (experimental)" OFF)
+mark_as_advanced(UA_ENABLE_PUBSUB_SOTXTIME)
+
+option(UA_ENABLE_PUBSUB_SUBSCRIBER_AMALGAMATION
+       "Use a workaround to enable subscriber to be compiled with amalgamation (experimental)" OFF)
+mark_as_advanced(UA_ENABLE_PUBSUB_SUBSCRIBER_AMALGAMATION)
+
 option(UA_ENABLE_STATUSCODE_DESCRIPTIONS "Enable conversion of StatusCode to human-readable error message" ON)
 mark_as_advanced(UA_ENABLE_STATUSCODE_DESCRIPTIONS)
 
diff --git a/examples/pubsub/tutorial_pubsub_publish.c b/examples/pubsub/tutorial_pubsub_publish.c
index 16523601..6271c81f 100644
--- a/examples/pubsub/tutorial_pubsub_publish.c
+++ b/examples/pubsub/tutorial_pubsub_publish.c
@@ -23,10 +23,67 @@
  * the system preconfiguration and connection can be found in
  * ``tutorial_pubsub_connection.c``.
  */
-
+#define _GNU_SOURCE
 #include "open62541.h"
 #include <signal.h>
 #include <stdio.h>
+#include <time.h>
+#include <pthread.h>
+
+/* Typically equal to a cycle time. Used to calculate the server starttime for UA_ENABLE_PUBSUB_SOTXTIME */
+#define PUBLISHING_INTERVAL_MS 0.125     //milliseconds, decimal cause of backwards compatibility
+#define PUBLISHING_INTERVAL_NS (UA_UInt64) (PUBLISHING_INTERVAL_MS * 1000000) //nanoseconds
+
+#ifdef UA_ENABLE_PUBSUB_SOTXTIME
+    /* Socket priority is used when mapping to user-defined MQPRIO/TAPRIO qdiscs */
+    #define SOCKET_PRIORITY 3
+
+    /* SO_TXTIME-specific additional socket config */
+    #define SOTXTIME_DEADLINE_MODE 0
+    #define SOTXTIME_RECEIVE_ERRORS 0
+    #define SOTXTIME_CLOCKID CLOCK_TAI
+
+    /* TODO: samplingOffset not implemented in open62541 code.
+     * OPC UA defines SAMPLING OFFSET as the point of time within a
+     * publishingInterval, at which the timer needs to wake up and start
+     * collecting data, and calling the respective publish/transmit functions
+     * so that packets can go out exactly at publishingOffset, before or at
+     * least close to it. This value MUST be less than publishing offset.
+     */
+    #define SAMPLING_OFFSET 0               //in nanoseconds
+
+    /* In cases where the publishingInterval is very small, SAMPLING_OFFSET
+     * might be too short to allow a program to sample the data and send it out
+     * at a specific time in the future. EARLY_SAMPLING_OFFSET allows specifying
+     * a packet to be transmitted (> publishingInterval) further into the future.
+     * It represents the amount of time before a publishingInterval when a
+     * sample should be obtained.
+     *
+     * X = 1st option, point in time where app/ua_server could start sampling data
+     * Y = 2nd option, point in time where app/ua_server could start sampling data
+     * Z = point in time where a packet should be transmitted.
+     *
+     *          |<--N x publishingInterval-->|<----publishingInterval---->|
+     *    X <-----EARLY_SAMPLING_OFFSET----->|                            |
+     *          |                            |<-SAMPLING_OFFSET-> Y       |
+     *          |                            |<--PUBLISHING_OFFSET---> Z  |
+     *          |                            |                            |
+     */
+    #define EARLY_SAMPLING_OFFSET 500000         //in nanoseconds
+
+    /* PUBLISHING_OFFSET is the internal target to send out the packets
+     * When used with SOTXTIME, packet WILL get transmitted exactly at this
+     * point of time. Without SOTXTIME, this is merely the target and
+     * transmits roughly at that time.
+     */
+    #define PUBLISHING_OFFSET 50000   //in nanoseconds
+
+    /* Set the thread's priority for scheduling prioritization and run on
+     * a fixed CPU core to avoid context switching.
+     */
+    #define THREAD_PRIORITY 90
+    #define THREAD_CPU_AFFINITY 3
+#endif
 
 UA_NodeId connectionIdent, publishedDataSetIdent, writerGroupIdent;
 
@@ -43,6 +100,12 @@ addPubSubConnection(UA_Server *server, UA_String *transportProfile,
     UA_Variant_setScalar(&connectionConfig.address, networkAddressUrl,
                          &UA_TYPES[UA_TYPES_NETWORKADDRESSURLDATATYPE]);
     connectionConfig.publisherId.numeric = UA_UInt32_random();
+#ifdef UA_ENABLE_PUBSUB_SOTXTIME
+    connectionConfig.sockPrio = SOCKET_PRIORITY;
+    connectionConfig.sotxtimeDeadlineMode = SOTXTIME_DEADLINE_MODE;
+    connectionConfig.sotxtimeReceiveErrors = SOTXTIME_RECEIVE_ERRORS;
+    connectionConfig.sotxtimeClockId = SOTXTIME_CLOCKID;
+#endif
     UA_Server_addPubSubConnection(server, &connectionConfig, &connectionIdent);
 }
 
@@ -98,10 +161,30 @@ addWriterGroup(UA_Server *server) {
     UA_WriterGroupConfig writerGroupConfig;
     memset(&writerGroupConfig, 0, sizeof(UA_WriterGroupConfig));
     writerGroupConfig.name = UA_STRING("Demo WriterGroup");
-    writerGroupConfig.publishingInterval = 0.031; //ms
+    writerGroupConfig.publishingInterval = PUBLISHING_INTERVAL_MS; //ms
     writerGroupConfig.enabled = UA_FALSE;
     writerGroupConfig.writerGroupId = 100;
     writerGroupConfig.encodingMimeType = UA_PUBSUB_ENCODING_UADP;
+
+#ifdef UA_ENABLE_PUBSUB_SOTXTIME
+    /* Initialize the first samplingTime, if sampling offset = 0, then it will be the basetime of publishingInterval */
+    struct timespec ts_x;
+    UA_UInt64 t_sampl_ns;
+    /* Get the current time and round of to the nearest 100ns. Then set to the
+     * next 100th publishingInterval into the future instead of starting immediately
+     */
+    clock_gettime(SOTXTIME_CLOCKID, &ts_x);    //TODO change gettime to UA_datetimenow
+    t_sampl_ns = (UA_UInt64) ((ts_x.tv_sec * 1000000000) + ((ts_x.tv_nsec/100) * 100));
+    t_sampl_ns += (100 * PUBLISHING_INTERVAL_NS) - (t_sampl_ns % PUBLISHING_INTERVAL_NS);
+    t_sampl_ns += SAMPLING_OFFSET;
+
+    writerGroupConfig.samplingTime.tv_sec = (UA_Int64) (t_sampl_ns / 1000000000);
+    writerGroupConfig.samplingTime.tv_nsec = (UA_Int64) (t_sampl_ns % 1000000000);
+
+    writerGroupConfig.publishingOffset = PUBLISHING_OFFSET;
+    writerGroupConfig.earlySamplingOffset = EARLY_SAMPLING_OFFSET;
+#endif
+
     /* The configuration flags for the messages are encapsulated inside the
      * message- and transport settings extension objects. These extension
      * objects are defined by the standard. e.g.
@@ -185,6 +268,44 @@ static int run(UA_String *transportProfile,
     return (int)retval;
 }
 
+#ifdef UA_ENABLE_PUBSUB_SOTXTIME
+/* Without setting this, application won't run at high priority, and
+ * may get pre-empted by other processes.
+ * TODO: change this to multi-arch scalable implementation, possibly a separate commit.
+ */
+static int set_realtime(pthread_t thread, int priority, uint32_t cpu)
+{
+	cpu_set_t cpuset;
+	struct sched_param sp;
+	int err, policy;
+	if (priority < 0) {
+		fprintf(stderr, "set_realtime() - priority argument < 0\n");
+		return -1;
+	}
+	err = pthread_getschedparam(thread, &policy, &sp);
+	if (err) {
+		fprintf(stderr, "pthread_getschedparam: %s\n", strerror(err));
+		return -1;
+	}
+	sp.sched_priority = priority;
+	err = pthread_setschedparam(thread, SCHED_FIFO, &sp);
+	if (err) {
+		fprintf(stderr, "pthread_setschedparam: %s\n", strerror(err));
+		return -1;
+	}
+	if (!cpu)
+		return 0;
+	CPU_ZERO(&cpuset);
+	CPU_SET(cpu, &cpuset);
+	err = pthread_setaffinity_np(thread, sizeof(cpu_set_t), &cpuset);
+	if (err) {
+		fprintf(stderr, "pthread_setaffinity_np: %s\n", strerror(err));
+		return -1;
+	}
+	return 0;
+}
+#endif
+
 static void
 usage(char *progname) {
     printf("usage: %s <uri> [device]\n", progname);
@@ -196,6 +317,12 @@ int main(int argc, char **argv) {
     UA_NetworkAddressUrlDataType networkAddressUrl =
         {UA_STRING_NULL , UA_STRING("opc.udp://224.0.0.22:4840/")};
 
+#ifdef UA_ENABLE_PUBSUB_SOTXTIME
+    if (set_realtime(pthread_self(), THREAD_PRIORITY, THREAD_CPU_AFFINITY)) {
+		return -1;
+	}
+#endif
+
     if (argc > 1) {
         if (strcmp(argv[1], "-h") == 0) {
             usage(argv[0]);
diff --git a/include/ua_config.h.in b/include/ua_config.h.in
index d085504c..2b6e67ce 100644
--- a/include/ua_config.h.in
+++ b/include/ua_config.h.in
@@ -27,6 +27,7 @@
 #cmakedefine UA_ENABLE_PUBSUB_ETH_UADP
 #cmakedefine UA_ENABLE_PUBSUB_DELTAFRAMES
 #cmakedefine UA_ENABLE_PUBSUB_INFORMATIONMODEL
+#cmakedefine UA_ENABLE_PUBSUB_SOTXTIME
 #cmakedefine UA_ENABLE_ENCRYPTION
 #cmakedefine UA_ENABLE_HISTORIZING
 #cmakedefine UA_ENABLE_SUBSCRIPTIONS_EVENTS
diff --git a/include/ua_plugin_pubsub.h b/include/ua_plugin_pubsub.h
index 40f7e35e..178ea5c5 100644
--- a/include/ua_plugin_pubsub.h
+++ b/include/ua_plugin_pubsub.h
@@ -47,6 +47,8 @@ struct UA_PubSubChannel {
     UA_UInt32 publisherId; /* unique identifier */
     UA_PubSubChannelState state;
     UA_PubSubConnectionConfig *connectionConfig; /* link to parent connection config */
+    UA_UInt64 txTimestamp;  /* Absolute timestamp of sending frame at publishingInterval + publishingOffset */
+    UA_UInt64 txTimestampCorrection;  /* Time needed to re-align the transmit timestamp when delay occurs */
     UA_SOCKET sockfd;
     void *handle; /* implementation specific data */
     /*@info for handle: each network implementation should provide an structure
diff --git a/include/ua_server_pubsub.h b/include/ua_server_pubsub.h
index 71b1394e..410d4606 100644
--- a/include/ua_server_pubsub.h
+++ b/include/ua_server_pubsub.h
@@ -112,6 +112,12 @@ typedef struct {
     size_t connectionPropertiesSize;
     UA_KeyValuePair *connectionProperties;
     UA_Variant connectionTransportSettings;
+#ifdef UA_ENABLE_PUBSUB_SOTXTIME
+    UA_UInt32 sockPrio;
+    UA_UInt16 sotxtimeDeadlineMode;
+    UA_UInt16 sotxtimeReceiveErrors;
+    clockid_t sotxtimeClockId;    //TODO: check if breaking multi-arch scalability, possible to use int?
+#endif
 } UA_PubSubConnectionConfig;
 
 UA_StatusCode UA_EXPORT
@@ -279,6 +285,9 @@ typedef struct {
     UA_Boolean enabled;
     UA_UInt16 writerGroupId;
     UA_Duration publishingInterval;
+    UA_UInt64 publishingOffset;
+    UA_UInt64 earlySamplingOffset;
+    struct timespec samplingTime;   // TODO: might be breaking multi-arch scalability.
     UA_Double keepAliveTime;
     UA_Byte priority;
     UA_MessageSecurityMode securityMode;
diff --git a/plugins/ua_network_pubsub_ethernet.c b/plugins/ua_network_pubsub_ethernet.c
index 882b9c07..a6708c93 100644
--- a/plugins/ua_network_pubsub_ethernet.c
+++ b/plugins/ua_network_pubsub_ethernet.c
@@ -8,9 +8,11 @@
 #include "ua_plugin_network.h"
 #include "ua_log_stdout.h"
 #include "ua_util.h"
+#include "ua_types.h"
 
 #include <netinet/ether.h>
 #include <linux/if_packet.h>
+#include <time.h>
 
 #include "ua_network_pubsub_ethernet.h"
 #include "../src/ua_util_internal.h"
@@ -19,11 +21,28 @@
 #define ETHERTYPE_UADP  0xb62c
 #endif
 
+#ifdef UA_ENABLE_PUBSUB_SOTXTIME
+    #ifndef SO_TXTIME
+        #define SO_TXTIME		61
+        #define SCM_TXTIME		SO_TXTIME
+    #endif
+
+    #define SO_SNDBUF_SIZE 5000
+
+/* SO_TXTIME/ETF qdisc specific options */
+struct sock_txtime {
+    clockid_t clockid;
+    uint16_t flags;
+};
+#endif
+
 /* Ethernet network layer specific internal data */
 typedef struct {
     int ifindex;
     UA_UInt16 vid;
     UA_Byte prio;
+    UA_UInt64 txTimestamp;
+    UA_UInt64 txTimestampCorrection;
     UA_Byte ifAddress[ETH_ALEN];
     UA_Byte targetAddress[ETH_ALEN];
 } UA_PubSubChannelDataEthernet;
@@ -153,6 +172,23 @@ UA_PubSubChannelEthernet_open(const UA_PubSubConnectionConfig *connectionConfig)
         return NULL;
     }
 
+#ifdef UA_ENABLE_PUBSUB_SOTXTIME
+    /* Set socket to use SO_TXTIME to pass the transmit time per packet via CMSG */
+    static struct sock_txtime sockTxtime;
+    sockTxtime.clockid = connectionConfig->sotxtimeClockId;
+    sockTxtime.flags = (connectionConfig->sotxtimeDeadlineMode |
+                        connectionConfig->sotxtimeReceiveErrors);
+
+    if(UA_setsockopt(sockFd, SOL_SOCKET, SO_TXTIME, &sockTxtime, sizeof(sockTxtime)) < 0)
+        UA_LOG_ERROR(UA_Log_Stdout, UA_LOGCATEGORY_SERVER,
+            "PubSub failed to setsockopt SO_TXTIME.");
+
+    int size = SO_SNDBUF_SIZE;
+    if(UA_setsockopt(sockFd, SOL_SOCKET,  SO_SNDBUF,  &size, sizeof(int)) < 0)
+        UA_LOG_ERROR(UA_Log_Stdout, UA_LOGCATEGORY_SERVER,
+            "PubSub failed to setsockopt SO_SNDBUF.");
+#endif
+
     /* get interface index */
     struct ifreq ifreq;
     memset(&ifreq, 0, sizeof(struct ifreq));
@@ -195,6 +231,13 @@ UA_PubSubChannelEthernet_open(const UA_PubSubConnectionConfig *connectionConfig)
         return NULL;
     }
 
+#ifdef UA_ENABLE_PUBSUB_SOTXTIME
+    /* Set socket priority */
+    if(UA_setsockopt(sockFd, SOL_SOCKET, SO_PRIORITY, &connectionConfig->sockPrio, sizeof(UA_UInt32)) < 0)
+        UA_LOG_ERROR(UA_Log_Stdout, UA_LOGCATEGORY_SERVER,
+                     "PubSub failed to set socket priority. ");
+#endif
+
     newChannel->handle = channelDataEthernet;
     newChannel->state = UA_PUBSUB_CHANNEL_PUB;
 
@@ -293,6 +336,15 @@ UA_PubSubChannelEthernet_send(UA_PubSubChannel *channel,
     size_t lenBuf;
     struct ether_header* ethHdr;
 
+#ifdef UA_ENABLE_PUBSUB_SOTXTIME
+    struct msghdr msg;
+    struct cmsghdr *cmsg;
+    char control[CMSG_SPACE(sizeof(__u64))];
+
+    UA_UInt64 txtime = channel->txTimestamp;
+    int raw_index  = channelDataEthernet->ifindex;
+#endif
+
     lenBuf = sizeof(*ethHdr) + 4 + buf->length;
     bufSend = (char*) UA_malloc(lenBuf);
     ethHdr = (struct ether_header*) bufSend;
@@ -324,6 +376,71 @@ UA_PubSubChannelEthernet_send(UA_PubSubChannel *channel,
     /* copy payload of ethernet message */
     memcpy(ptrCur, buf->data, buf->length);
 
+#ifdef UA_ENABLE_PUBSUB_SOTXTIME
+    /* SO_TXTIME Requires sendmsg, add the headers to msg struct here */
+    struct sockaddr_ll sinll;
+    struct iovec iov;
+    ssize_t rc;
+
+    memset(&sinll, 0, sizeof(sinll));
+    sinll.sll_family = AF_PACKET;
+    sinll.sll_ifindex = raw_index; 		/* Network device's index */
+    sinll.sll_halen = ETH_ALEN; 		    /* Address length*/
+    sinll.sll_addr[0] = channelDataEthernet->targetAddress[0];	/* Destination MAC */
+    sinll.sll_addr[1] = channelDataEthernet->targetAddress[1];
+    sinll.sll_addr[2] = channelDataEthernet->targetAddress[2];
+    sinll.sll_addr[3] = channelDataEthernet->targetAddress[3];
+    sinll.sll_addr[4] = channelDataEthernet->targetAddress[4];
+    sinll.sll_addr[5] = channelDataEthernet->targetAddress[5];
+
+    memset(&iov, 0, sizeof(iov));
+    iov.iov_base = bufSend;
+    iov.iov_len = lenBuf;
+
+    memset(&msg, 0, sizeof(msg));
+    msg.msg_name = &sinll;
+    msg.msg_namelen = sizeof(sinll);
+    msg.msg_iov = &iov;
+    msg.msg_iovlen = 1;
+
+    /* Specify the transmission time in the CMSG. */
+    if (txtime > 0) {
+        msg.msg_control = control;
+        msg.msg_controllen = sizeof(control);
+
+        cmsg = CMSG_FIRSTHDR(&msg);
+        cmsg->cmsg_level = SOL_SOCKET;
+        cmsg->cmsg_type = SCM_TXTIME;
+        cmsg->cmsg_len = CMSG_LEN(sizeof(__u64));
+        *((__u64 *) CMSG_DATA(cmsg)) = (__u64) txtime;
+    } else {
+        UA_LOG_ERROR(UA_Log_Stdout, UA_LOGCATEGORY_SERVER,
+            "Txtime 0, problem!.\n");
+    }
+
+    /* Use sendmsg to transmit with TXTIME in the CMSG */
+    rc = sendmsg(channel->sockfd, &msg, 0);
+    if(rc  < 0) {
+        if (errno == 105) {
+            /* Packet was late, likely due to app's internal timing is slipping */
+            struct timespec ts_x;
+
+            /* Find the clock difference and pass it back to the callback */
+            clock_gettime(CLOCK_TAI, &ts_x);
+            channel->txTimestampCorrection = channel->txTimestamp - (UA_UInt64) (ts_x.tv_sec * 1000000000 - ts_x.tv_nsec);
+
+            /* Skip this packet, do not print warning as it might affect
+             * the timestamp correction mechanism.
+             */
+            return UA_TIMESTAMPSTORETURN_INVALID;
+        }
+
+        UA_LOG_ERROR(UA_Log_Stdout, UA_LOGCATEGORY_SERVER,
+            "PubSub connection send failed. Send message failed.\n");
+        UA_free(bufSend);
+        return UA_STATUSCODE_BADINTERNALERROR;
+    }
+#else
     ssize_t rc;
     rc = UA_send(channel->sockfd, bufSend, lenBuf, 0);
     if(rc  < 0) {
@@ -332,8 +449,9 @@ UA_PubSubChannelEthernet_send(UA_PubSubChannel *channel,
         UA_free(bufSend);
         return UA_STATUSCODE_BADINTERNALERROR;
     }
-    UA_free(bufSend);
+#endif
 
+    UA_free(bufSend);
     return UA_STATUSCODE_GOOD;
 }
 
diff --git a/src/pubsub/ua_pubsub.c b/src/pubsub/ua_pubsub.c
index f8c4ff07..2df86e6d 100644
--- a/src/pubsub/ua_pubsub.c
+++ b/src/pubsub/ua_pubsub.c
@@ -4,7 +4,9 @@
  *
  * Copyright (c) 2017-2018 Fraunhofer IOSB (Author: Andreas Ebner)
  */
+#define _GNU_SOURCE
 
+#include <time.h>
 #include "server/ua_server_internal.h"
 #include "ua_types_encoding_binary.h"
 
@@ -1136,7 +1138,43 @@ UA_WriterGroup_publishCallback(UA_Server *server, UA_WriterGroup *writerGroup) {
                 UA_ByteString_deleteMembers(&buf);
                 return;
             };
+
+#ifdef UA_ENABLE_PUBSUB_SOTXTIME
+
+            struct timespec *ts_wk = &writerGroup->config.samplingTime;
+
+            /* Wake up to the first samplingOffset of a publishingInterval */
+            if (clock_nanosleep(CLOCK_TAI, TIMER_ABSTIME, ts_wk, NULL)) {
+                fprintf(stderr, "Error: failed to sleep\n");
+                break;
+            }
+
+            /* Sampler code should go here */
+
+            /* TODO: for loop for pubOffset array, batch schedule packets into the future? */
+
+            //Pass in the txtime to each individual channel.
+            connection->channel->txTimestamp = (UA_UInt64) ts_wk->tv_sec * 1000000000
+                                               + (UA_UInt64) ts_wk->tv_nsec
+                                               + writerGroup->config.earlySamplingOffset
+                                               + writerGroup->config.publishingOffset;
+
+            UA_StatusCode ret = connection->channel->send(connection->channel, NULL, &buf);
+            if (ret == UA_TIMESTAMPSTORETURN_INVALID) {
+                /* Attempting to fix by skipping several intervals to the future.*/
+                UA_UInt64 publishingIntervalNs = (UA_UInt64) (writerGroup->config.publishingInterval * 1000000); // ms to ns
+                ts_wk->tv_nsec += (UA_Int64) (connection->channel->txTimestampCorrection / publishingIntervalNs * publishingIntervalNs);
+            }
+
+            /* TODO: sleep till second samplingOffset? for array implementation of PublishingOffset */
+
+            //Increment 1 period for the next cycle
+            ts_wk->tv_nsec += (UA_Int64) (writerGroup->config.publishingInterval * 1000000); //convert ms to ns
+            ts_wk->tv_sec += ts_wk->tv_nsec / 1000000000;
+            ts_wk->tv_nsec = ts_wk->tv_nsec % 1000000000;
+#else
             connection->channel->send(connection->channel, NULL, &buf);
+#endif
         }
         //The stack allocated sizes and dataSetWriterIds field must be set to NULL to prevent invalid free.
         nmStore[i].payload.dataSetPayload.sizes = NULL;
diff --git a/src/server/ua_server.c b/src/server/ua_server.c
index a201d029..86523a43 100644
--- a/src/server/ua_server.c
+++ b/src/server/ua_server.c
@@ -496,6 +496,7 @@ UA_Server_run_iterate(UA_Server *server, UA_Boolean waitInternal) {
     /* Listen on the networklayer */
     for(size_t i = 0; i < server->config.networkLayersSize; ++i) {
         UA_ServerNetworkLayer *nl = &server->config.networkLayers[i];
+        //TODO: mute when null, for example when pubsub is being used.
         nl->listen(nl, server, 0);
     }
 
diff --git a/src/ua_timer.c b/src/ua_timer.c
index b5994936..47b4a160 100644
--- a/src/ua_timer.c
+++ b/src/ua_timer.c
@@ -9,6 +9,10 @@
 #include "ua_util_internal.h"
 #include "ua_timer.h"
 
+#ifdef UA_ENABLE_PUBSUB_SOTXTIME
+//    #include "server/ua_server_internal.h"
+#endif
+
 /* Only one thread operates on the repeated jobs. This is usually the "main"
  * thread with the event loop. All other threads introduce changes via a
  * multi-producer single-consumer (MPSC) queue. The queue is based on a design
@@ -112,7 +116,7 @@ UA_Timer_addRepeatedCallback(UA_Timer *t, UA_ApplicationCallback callback,
     tc->callback = callback;
     tc->application = application;
     tc->data = data;
-    tc->nextTime = UA_DateTime_nowMonotonic() + (UA_DateTime)tc->interval;
+    tc->nextTime = UA_DateTime_nowMonotonic() + (UA_DateTime)tc->interval;//todo: use nextTime instead of samplingTime
 
     /* Set the output identifier */
     if(callbackId)
-- 
2.17.1


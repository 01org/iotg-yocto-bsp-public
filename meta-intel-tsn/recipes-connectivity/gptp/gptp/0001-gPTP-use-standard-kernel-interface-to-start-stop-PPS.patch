From 77829c7131a5cc95d3531161ff2f9f5d9efc28a3 Mon Sep 17 00:00:00 2001
From: abdulari <abdul.arif.b.abdul.muttalib@intel.com>
Date: Mon, 18 Feb 2019 16:24:32 +0800
Subject: [PATCH] gPTP: use standard kernel interface to start/stop PPS

igb_avb module has been patched with kernel standard API in OpenAvnu
pull request #503 to configure SDP to output PPS.
https://github.com/AVnu/OpenAvnu/pull/503

As a result, gPTP daemon can now use the Linux kernel ioctl API
PTP_PIN_SETFUNC and PTP_PEROUT_REQUEST to start/stop PPS instead of
program I210 registers directly through libigb. This removes gPTP
daemon's dependency on libigb to output PPS.

Signed-off-by: abdulari <abdul.arif.b.abdul.muttalib@intel.com>
---
 linux/build/Makefile                      |  14 +--
 linux/src/linux_hal_generic.cpp           |  76 ++++++++++++--
 linux/src/linux_hal_generic.hpp           |  15 +--
 linux/src/linux_hal_generic_tsprivate.hpp |  13 ---
 linux/src/linux_hal_i210.cpp              | 162 ------------------------------
 5 files changed, 69 insertions(+), 211 deletions(-)
 delete mode 100644 linux/src/linux_hal_i210.cpp

diff --git a/linux/build/Makefile b/linux/build/Makefile
index 1e00b1a..611d4a2 100644
--- a/linux/build/Makefile
+++ b/linux/build/Makefile
@@ -89,16 +89,7 @@ HEADER_FILES = $(COMMON_DIR)/ether_port.hpp\
 		$(SRC_DIR)/linux_hal_persist_file.hpp\
 		$(SRC_DIR)/platform.hpp
 
-ifeq ($(ARCH),I210)
-	IGB_LIB_INCPATH=../../../../lib/igb/
-	IGB_LIB_PATH=../../../../lib/igb/
-	CFLAGS_G += -I$(IGB_LIB_INCPATH) -DWITH_IGBLIB
-	LDFLAGS_G += -lz -ligb -lpci -L$(IGB_LIB_PATH)
-	OBJ_FILES += $(OBJ_DIR)/linux_hal_generic.o \
-		$(OBJ_DIR)/linux_hal_generic_adj.o
-	OBJ_FILES += $(OBJ_DIR)/linux_hal_i210.o
-	HEADER_FILES += $(SRC_DIR)/linux_hal_generic.hpp
-else ifeq ($(ARCH),IntelCE)
+ifeq ($(ARCH),IntelCE)
 	INTELCE_INCPATH=/home/hitesh/work/smd/Dinerout/i686-linux-elf/include/
 	INTELCE_LINUX_INCPATH=/home/hitesh/work/smd/Dinerout/i686-linux-elf/include/linux_user
 	INTELCE_LIBPATH=/home/hitesh/work/smd/Dinerout/i686-linux-elf/lib/
@@ -152,9 +143,6 @@ $(OBJ_DIR)/linux_hal_generic.o: $(SRC_DIR)/linux_hal_generic.cpp $(HEADER_FILES)
 $(OBJ_DIR)/linux_hal_generic_adj.o: $(SRC_DIR)/linux_hal_generic_adj.cpp $(HEADER_FILES)
 	$(CXX) $(CPPFLAGS) $(CXXFLAGS) -c $(SRC_DIR)/linux_hal_generic_adj.cpp -o $(OBJ_DIR)/linux_hal_generic_adj.o
 
-$(OBJ_DIR)/linux_hal_i210.o: $(SRC_DIR)/linux_hal_i210.cpp $(HEADER_FILES)
-	$(CXX) $(CPPFLAGS) $(CXXFLAGS) -c $(SRC_DIR)/linux_hal_i210.cpp -o $(OBJ_DIR)/linux_hal_i210.o
-
 $(OBJ_DIR)/linux_hal_intelce.o: $(SRC_DIR)/linux_hal_intelce.cpp $(HEADER_FILES)
 	$(CXX) $(CPPFLAGS) $(CXXFLAGS) -c $(SRC_DIR)/linux_hal_intelce.cpp -o $(OBJ_DIR)/linux_hal_intelce.o
 
diff --git a/linux/src/linux_hal_generic.cpp b/linux/src/linux_hal_generic.cpp
index 9eeba46..807ecb2 100644
--- a/linux/src/linux_hal_generic.cpp
+++ b/linux/src/linux_hal_generic.cpp
@@ -196,16 +196,10 @@ int findPhcIndex( InterfaceLabel *iface_label ) {
 
 LinuxTimestamperGeneric::~LinuxTimestamperGeneric() {
 	if( _private != NULL ) delete _private;
-#ifdef WITH_IGBLIB
-	if( igb_private != NULL ) delete igb_private;
-#endif
 }
 
 LinuxTimestamperGeneric::LinuxTimestamperGeneric() {
 	_private = NULL;
-#ifdef WITH_IGBLIB
-	igb_private = NULL;
-#endif
 	sd = -1;
 }
 
@@ -222,9 +216,7 @@ bool LinuxTimestamperGeneric::HWTimestamper_init
 	cross_stamp_good = false;
 	int phc_index;
 	char ptp_device[] = PTP_DEVICE;
-#ifdef PTP_HW_CROSSTSTAMP
 	struct ptp_clock_caps ptp_capability;
-#endif
 	_private = new LinuxTimestamperGenericPrivate;
 
 	pthread_mutex_init( &_private->cross_stamp_lock, NULL );
@@ -239,22 +231,23 @@ bool LinuxTimestamperGeneric::HWTimestamper_init
 	snprintf
 		( ptp_device+PTP_DEVICE_IDX_OFFS,
 		  sizeof(ptp_device)-PTP_DEVICE_IDX_OFFS, "%d", phc_index );
-	GPTP_LOG_ERROR("Using clock device: %s", ptp_device);
+	GPTP_LOG_INFO("Using clock device: %s", ptp_device);
 	phc_fd = open( ptp_device, O_RDWR );
 	if( phc_fd == -1 || (_private->clockid = FD_TO_CLOCKID(phc_fd)) == -1 ) {
 		GPTP_LOG_ERROR("Failed to open PTP clock device");
 		return false;
 	}
 
-#ifdef PTP_HW_CROSSTSTAMP
 	// Query PTP stack for availability of HW cross-timestamp
 	if( ioctl( phc_fd, PTP_CLOCK_GETCAPS, &ptp_capability ) == -1 )
 	{
 		GPTP_LOG_ERROR("Failed to query PTP clock capabilities");
 		return false;
 	}
+#ifdef PTP_HW_CROSSTSTAMP
 	precise_timestamp_enabled = ptp_capability.cross_timestamping;
 #endif
+	pps_enabled = ptp_capability.n_per_out > 0;
 
 	if( !resetFrequencyAdjustment() ) {
 		GPTP_LOG_ERROR("Failed to reset (zero) frequency adjustment");
@@ -495,3 +488,66 @@ bool LinuxTimestamperGeneric::HWTimestamper_gettime
 
 	return true;
 }
+
+bool LinuxTimestamperGeneric::HWTimestamper_PPS_start() {
+	struct ptp_perout_request req;
+	struct ptp_pin_desc desc;
+	struct timespec ts;
+
+	if (pps_enabled == false)
+		return true;
+
+	if (clock_gettime(_private->clockid, &ts)) {
+		GPTP_LOG_ERROR("Failed to get clock time: %s", strerror(errno));
+		return false;
+	}
+
+	// Configure SDP for periodic output
+	memset(&desc, 0, sizeof(desc));
+	desc.func = PTP_PF_PEROUT;
+	if (ioctl(phc_fd, PTP_PIN_SETFUNC, &desc)) {
+		GPTP_LOG_ERROR
+			("Failed to set SDP function: %s", strerror(errno));
+		return false;
+	}
+
+	// Configure SDP to start periodic output
+	memset(&req, 0, sizeof(req));
+	// First edge in 1-2 seconds
+	req.start.sec = ts.tv_sec + 2;
+	req.period.sec = 1;
+	if (ioctl(phc_fd, PTP_PEROUT_REQUEST, &req)) {
+		GPTP_LOG_ERROR("Failed to start PPS: %s", strerror(errno));
+		return false;
+	}
+	GPTP_LOG_INFO("PPS started");
+
+	return true;
+}
+
+bool LinuxTimestamperGeneric::HWTimestamper_PPS_stop() {
+	struct ptp_perout_request req;
+	struct ptp_pin_desc desc;
+
+	if (pps_enabled == false)
+		return true;
+
+	// Stop SDP to output periodic output
+	memset(&req, 0, sizeof(req));
+	if (ioctl(phc_fd, PTP_PEROUT_REQUEST, &req)) {
+		GPTP_LOG_ERROR("Failed to stop PPS: %s", strerror(errno));
+		return false;
+	}
+
+	// Disable SDP for periodic output
+	memset(&desc, 0, sizeof(desc));
+	desc.func = PTP_PF_NONE;
+	if (ioctl(phc_fd, PTP_PIN_SETFUNC, &desc)) {
+		GPTP_LOG_ERROR
+			("Failed to clear SDP function: %s", strerror(errno));
+		return false;
+	}
+	GPTP_LOG_INFO("PPS stopped");
+
+	return true;
+}
diff --git a/linux/src/linux_hal_generic.hpp b/linux/src/linux_hal_generic.hpp
index 943294f..4c5d795 100644
--- a/linux/src/linux_hal_generic.hpp
+++ b/linux/src/linux_hal_generic.hpp
@@ -44,11 +44,6 @@ struct LinuxTimestamperGenericPrivate;
  */
 typedef struct LinuxTimestamperGenericPrivate * LinuxTimestamperGenericPrivate_t;
 
-#ifdef WITH_IGBLIB
-struct LinuxTimestamperIGBPrivate;
-typedef struct LinuxTimestamperIGBPrivate * LinuxTimestamperIGBPrivate_t;
-#endif
-
 /**
  * @brief Linux timestamper generic interface
  */
@@ -65,13 +60,9 @@ private:
 #ifdef PTP_HW_CROSSTSTAMP
 	bool precise_timestamp_enabled;
 #endif
-
+	bool pps_enabled;
 	TicketingLock *net_lock;
 
-#ifdef WITH_IGBLIB
-	LinuxTimestamperIGBPrivate_t igb_private;
-#endif
-
 public:
 	/**
 	 * @brief Default constructor. Initializes internal variables
@@ -188,10 +179,8 @@ public:
 	 */
 	virtual bool HWTimestamper_adjclockrate( float freq_offset ) const;
 
-#ifdef WITH_IGBLIB
-	bool HWTimestamper_PPS_start( );
+	bool HWTimestamper_PPS_start();
 	bool HWTimestamper_PPS_stop();
-#endif
 
 	/**
 	 * @brief deletes LinuxTimestamperGeneric object
diff --git a/linux/src/linux_hal_generic_tsprivate.hpp b/linux/src/linux_hal_generic_tsprivate.hpp
index a43e1c3..20880cb 100644
--- a/linux/src/linux_hal_generic_tsprivate.hpp
+++ b/linux/src/linux_hal_generic_tsprivate.hpp
@@ -37,19 +37,6 @@
 /**@file*/
 
 #include <pthread.h>
-#ifdef WITH_IGBLIB
-extern "C" {
-#include <igb.h>
-}
-/**
- * @brief Private IGB structure.
- */
-struct LinuxTimestamperIGBPrivate {
-	device_t igb_dev;
-	bool igb_initd;
-};
-#endif
-
 /**
  * @brief Provides private members for the LinuxTimestamperGeneric class
  */
diff --git a/linux/src/linux_hal_i210.cpp b/linux/src/linux_hal_i210.cpp
deleted file mode 100644
index 117a590..0000000
--- a/linux/src/linux_hal_i210.cpp
+++ /dev/null
@@ -1,162 +0,0 @@
-/******************************************************************************
-
-  Copyright (c) 2012, Intel Corporation 
-  All rights reserved.
-  
-  Redistribution and use in source and binary forms, with or without 
-  modification, are permitted provided that the following conditions are met:
-  
-   1. Redistributions of source code must retain the above copyright notice, 
-      this list of conditions and the following disclaimer.
-  
-   2. Redistributions in binary form must reproduce the above copyright 
-      notice, this list of conditions and the following disclaimer in the 
-      documentation and/or other materials provided with the distribution.
-  
-   3. Neither the name of the Intel Corporation nor the names of its 
-      contributors may be used to endorse or promote products derived from 
-      this software without specific prior written permission.
-  
-  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
-  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
-  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
-  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
-  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
-  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
-  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
-  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
-  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
-  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-  POSSIBILITY OF SUCH DAMAGE.
-
-******************************************************************************/
-
-#include <linux_hal_generic.hpp>
-#include <linux_hal_generic_tsprivate.hpp>
-#include <errno.h>
-
-extern "C" {
-#include <pci/pci.h>
-#include <igb.h>
-}
-
-#define IGB_BIND_NAMESZ 24
-
-#define TSSDP     0x003C // Time Sync SDP Configuration Register
-#define FREQOUT0  0xB654 
-#define TSAUXC    0xB640 
-#define IGB_CTRL  0x0000
-#define SYSTIMH   0xB604
-#define TRGTTIML0 0xB644
-#define TRGTTIMH0 0xB648
-
-
-static int
-pci_connect( device_t *igb_dev )
-{
-	char devpath[IGB_BIND_NAMESZ];
-	struct pci_access *pacc;
-	struct pci_dev *dev;
-	int err;
-
-	memset(igb_dev, 0, sizeof(device_t));
-	pacc = pci_alloc();
-	pci_init(pacc);
-	pci_scan_bus(pacc);
-
-	for (dev = pacc->devices; dev; dev = dev->next) {
-		pci_fill_info(dev, PCI_FILL_IDENT | PCI_FILL_BASES | PCI_FILL_CLASS);
-		igb_dev->pci_vendor_id = dev->vendor_id;
-		igb_dev->pci_device_id = dev->device_id;
-		igb_dev->domain = dev->domain;
-		igb_dev->bus = dev->bus;
-		igb_dev->dev = dev->dev;
-		igb_dev->func = dev->func;
-		snprintf(devpath, IGB_BIND_NAMESZ, "%04x:%02x:%02x.%d",
-				dev->domain, dev->bus, dev->dev, dev->func);
-		err = igb_probe(igb_dev);
-		if (err) {
-			continue;
-		}
-		GPTP_LOG_INFO("attaching to %s", devpath);
-		err = igb_attach(devpath, igb_dev);
-		if (err) {
-			GPTP_LOG_ERROR("attach failed! (%s)", strerror(err));
-			continue;
-		}
-		/*igb_attach_tx missing here ???*/
-		goto out;
-	}
-	pci_cleanup(pacc);
-	return  ENXIO;
-out:
-	pci_cleanup(pacc);
-	return  0;
-}
-
-
-bool LinuxTimestamperGeneric::HWTimestamper_PPS_start( ) {
-	unsigned tssdp;
-	unsigned freqout;
-	unsigned ctrl;
-	unsigned tsauxc;
-	unsigned trgttimh;
-
-	if( igb_private == NULL ) {
-		igb_private = new LinuxTimestamperIGBPrivate;
-	}
-
-	if( pci_connect( &igb_private->igb_dev ) != 0 ) {
-		return false;
-	}
-
-	if( igb_init( &igb_private->igb_dev ) != 0 ) {
-		return false;
-	}
-
-	igb_private->igb_initd = true;
-
-	igb_lock( &igb_private->igb_dev );
-
-	// Edges must be second aligned
-	igb_readreg( &igb_private->igb_dev, SYSTIMH, &trgttimh );
-	trgttimh += 2;  // First edge in 1-2 seconds
-	igb_writereg(&igb_private->igb_dev, TRGTTIMH0, trgttimh );
-	igb_writereg(&igb_private->igb_dev, TRGTTIML0, 0 );
-
-	freqout = 500000000;
-	igb_writereg(&igb_private->igb_dev, FREQOUT0, freqout );
-
-	igb_readreg(&igb_private->igb_dev, IGB_CTRL, &ctrl );
-	ctrl |= 0x400000; // set bit 22 SDP0 enabling output
-	igb_writereg(&igb_private->igb_dev, IGB_CTRL, ctrl );
-
-	igb_readreg(&igb_private->igb_dev, TSSDP, &tssdp);
-	tssdp &= ~0x40; // Set SDP0 output to freq clock 0
-	tssdp |= 0x80; 
-	igb_writereg(&igb_private->igb_dev, TSSDP, tssdp);
-  
-	igb_readreg(&igb_private->igb_dev, TSSDP, &tssdp);
-	tssdp |= 0x100; // set bit 8 -> SDP0 Time Sync Output
-	igb_writereg(&igb_private->igb_dev, TSSDP, tssdp);
-
-	igb_readreg( &igb_private->igb_dev, TSAUXC, &tsauxc );
-	tsauxc |= 0x14;
-	igb_writereg( &igb_private->igb_dev, TSAUXC, tsauxc );
-
-	igb_unlock( &igb_private->igb_dev );
-
-	return true;
-}
-
-bool LinuxTimestamperGeneric::HWTimestamper_PPS_stop() {
-	unsigned tsauxc;
-
-	if( !igb_private->igb_initd ) return false;
-
-	igb_readreg( &igb_private->igb_dev, TSAUXC, &tsauxc );
-	tsauxc &= ~0x14; // set bit 4 and bit 2 -> AUXC ST0 and EN_CLK0
-	igb_writereg( &igb_private->igb_dev, TSAUXC, tsauxc );
-
-	return true;
-}
-- 
1.9.1


diff -x .git -x .gitignore -Naur mesa/gms-integration isg_gms-mesa/gms-integration
--- mesa/gms-integration	1970-01-01 07:30:00.000000000 +0730
+++ isg_gms-mesa/gms-integration	2017-02-01 02:06:01.250089565 +0800
@@ -0,0 +1,7 @@
+###
+### GMS integration
+###
+upstream c8ece92ded9337b9ed60aa9568b41313025a1406
+	docs: add sha256 checksums for 13.0.3
+topic/vpg_ufo_patches a7636fdc53a8362fad154932e5fe3745b71748d9
+	gbm-dri: Duplicate image after checking its format.
diff -x .git -x .gitignore -Naur mesa/src/egl/drivers/dri2/egl_dri2.c isg_gms-mesa/src/egl/drivers/dri2/egl_dri2.c
--- mesa/src/egl/drivers/dri2/egl_dri2.c	2017-02-01 02:09:24.413829633 +0800
+++ isg_gms-mesa/src/egl/drivers/dri2/egl_dri2.c	2017-02-01 02:06:01.322090890 +0800
@@ -226,15 +226,6 @@
          dri_masks[3] = value;
          break;
 
-      case __DRI_ATTRIB_ACCUM_RED_SIZE:
-      case __DRI_ATTRIB_ACCUM_GREEN_SIZE:
-      case __DRI_ATTRIB_ACCUM_BLUE_SIZE:
-      case __DRI_ATTRIB_ACCUM_ALPHA_SIZE:
-         /* Don't expose visuals with the accumulation buffer. */
-         if (value > 0)
-            return NULL;
-         break;
-
       case __DRI_ATTRIB_FRAMEBUFFER_SRGB_CAPABLE:
          srgb = value != 0;
          if (!disp->Extensions.KHR_gl_colorspace && srgb)
@@ -1277,6 +1268,10 @@
    if (!dri2_dpy)
       return _eglError(EGL_NOT_INITIALIZED, "eglMakeCurrent");
 
+   /* check display */
+   if (!dri2_dpy)
+      return _eglError(EGL_BAD_DISPLAY, "eglMakeCurrent");
+
    /* make new bindings */
    if (!_eglBindContext(ctx, dsurf, rsurf, &old_ctx, &old_dsurf, &old_rsurf)) {
       /* _eglBindContext already sets the EGL error (in _eglCheckMakeCurrent) */
diff -x .git -x .gitignore -Naur mesa/src/egl/drivers/dri2/egl_dri2_fallbacks.h isg_gms-mesa/src/egl/drivers/dri2/egl_dri2_fallbacks.h
--- mesa/src/egl/drivers/dri2/egl_dri2_fallbacks.h	2017-02-01 02:09:23.653815634 +0800
+++ isg_gms-mesa/src/egl/drivers/dri2/egl_dri2_fallbacks.h	2017-02-01 02:06:01.322090890 +0800
@@ -37,11 +37,16 @@
    return NULL;
 }
 
+/*
+ * If config doesn't support pbuffer, there is a need to set egl error.
+ * EGL1.4 spec #3.5.2 - EGL_BAD_MATCH
+ */
 static inline _EGLSurface *
 dri2_fallback_create_pbuffer_surface(_EGLDriver *drv, _EGLDisplay *disp,
                                      _EGLConfig *conf,
                                      const EGLint *attrib_list)
 {
+   _eglError(EGL_BAD_MATCH, "dri2_fallback_create_pbuffer_surface");
    return NULL;
 }
 
diff -x .git -x .gitignore -Naur mesa/src/egl/drivers/dri2/platform_wayland.c isg_gms-mesa/src/egl/drivers/dri2/platform_wayland.c
--- mesa/src/egl/drivers/dri2/platform_wayland.c	2017-02-01 02:09:24.413829633 +0800
+++ isg_gms-mesa/src/egl/drivers/dri2/platform_wayland.c	2017-02-01 02:06:01.322090890 +0800
@@ -44,6 +44,7 @@
 
 #include <wayland-client.h>
 #include "wayland-drm-client-protocol.h"
+#include "wayland-egl-priv.h"
 
 enum wl_drm_format_flags {
    HAS_ARGB8888 = 1,
@@ -168,8 +169,8 @@
    dri2_surf->wl_win->resize_callback = resize_callback;
    dri2_surf->wl_win->destroy_window_callback = destroy_window_callback;
 
-   dri2_surf->base.Width =  -1;
-   dri2_surf->base.Height = -1;
+   dri2_surf->base.Width = window->width;
+   dri2_surf->base.Height = window->height;
 
    config = dri2_get_dri_config(dri2_conf, EGL_WINDOW_BIT,
                                 dri2_surf->base.GLColorspace);
diff -x .git -x .gitignore -Naur mesa/src/egl/drivers/dri2/platform_x11.c isg_gms-mesa/src/egl/drivers/dri2/platform_x11.c
--- mesa/src/egl/drivers/dri2/platform_x11.c	2017-02-01 02:09:24.413829633 +0800
+++ isg_gms-mesa/src/egl/drivers/dri2/platform_x11.c	2017-02-01 02:06:01.322090890 +0800
@@ -235,6 +235,16 @@
          goto cleanup_surf;
       }
 
+      /*
+       * WA for EGL to avoid attempts to create surface with 0 width or height.
+       * Mainly for eglCreatePbufferSurface, which creation with 0 width or
+       * height causes XServer unstable.
+       */
+      if (dri2_surf->base.Width == 0)
+          dri2_surf->base.Width = 1;
+      if (dri2_surf->base.Height == 0)
+          dri2_surf->base.Height = 1;
+
       dri2_surf->drawable = xcb_generate_id(dri2_dpy->conn);
       xcb_create_pixmap(dri2_dpy->conn, conf->BufferSize,
                        dri2_surf->drawable, screen->root,
@@ -389,7 +399,11 @@
    (*dri2_dpy->core->destroyDrawable)(dri2_surf->dri_drawable);
    
    if (dri2_dpy->dri2) {
-      xcb_dri2_destroy_drawable (dri2_dpy->conn, dri2_surf->drawable);
+       xcb_void_cookie_t cookie = xcb_dri2_destroy_drawable_checked(dri2_dpy->conn, dri2_surf->drawable);
+       xcb_generic_error_t* error = xcb_request_check(dri2_dpy->conn, cookie);
+       /* Possible adding error handling here. Currently errors are checked here (but ignored) to prevent process termination
+        if native window was already destroyed. */
+       free(error);
    } else {
       assert(dri2_dpy->swrast);
       swrastDestroyDrawable(dri2_dpy, dri2_surf);
@@ -887,6 +901,25 @@
    struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);
    struct dri2_egl_surface *dri2_surf = dri2_egl_surface(draw);
 
+   /*
+    * Updating surface width and height fields for querying size by
+    * eglQuerySurface with EGL_WIDTH, EGL_HEIGHT It's needed for window surface
+    * when window is resized.
+    */
+   if (!(draw->Type & EGL_PBUFFER_BIT)) {
+      xcb_generic_error_t *error = NULL;
+      xcb_get_geometry_cookie_t cookie = xcb_get_geometry (dri2_dpy->conn, dri2_surf->drawable);
+      xcb_get_geometry_reply_t *reply = xcb_get_geometry_reply (dri2_dpy->conn, cookie, &error);
+      if (reply != NULL)
+      {
+         dri2_surf->base.Width = reply->width;
+         dri2_surf->base.Height = reply->height;
+         free(reply);
+      }
+      if (error != NULL)
+        free(error);
+   }
+
    if (dri2_dpy->dri2) {
       if (dri2_x11_swap_buffers_msc(drv, disp, draw, 0, 0, 0) != -1) {
           return EGL_TRUE;
diff -x .git -x .gitignore -Naur mesa/src/egl/main/eglapi.c isg_gms-mesa/src/egl/main/eglapi.c
--- mesa/src/egl/main/eglapi.c	2017-02-01 02:09:24.413829633 +0800
+++ isg_gms-mesa/src/egl/main/eglapi.c	2017-02-01 02:06:01.326090964 +0800
@@ -102,6 +102,63 @@
 #include "eglimage.h"
 #include "eglsync.h"
 
+/**
+ * List item containing window related to surface
+ */
+typedef struct
+{
+    struct window_list_item *next;
+    EGLNativeWindowType native_window;
+    EGLSurface attached_surface;
+} window_list_item;
+
+window_list_item *window_surface_association_list = NULL;
+
+/*
+ * Checks if a EGLWindow already have a created surface.
+ */
+static inline bool
+is_window_associated_with_surface(EGLNativeWindowType window)
+{
+   window_list_item *it = window_surface_association_list;
+   for (; it != NULL; it = (window_list_item*)it->next) {
+       if (it->native_window == window)
+          return true;
+   }
+
+   return false;
+}
+
+static inline void
+associate_window_with_surface_list(EGLNativeWindowType window, EGLSurface surface)
+{
+   window_list_item *attach = calloc(1, sizeof(window_list_item));
+   assert(attach);
+
+   attach->next = (struct window_list_item*)window_surface_association_list;
+   attach->native_window = window;
+   attach->attached_surface = surface;
+
+   window_surface_association_list = attach;
+}
+
+static inline void
+disassociate_window_with_surface_list(EGLSurface surface)
+{
+   window_list_item *it = window_surface_association_list, *last = NULL;
+   for (; it != NULL; it = (window_list_item*)it->next) {
+      if (it->attached_surface == surface) {
+         if (it == window_surface_association_list) {
+            window_surface_association_list = (window_list_item*)it->next;
+         } else {
+            last->next = it->next;
+         }
+         free(it);
+         return;
+      }
+      last = it;
+   }
+}
 
 /**
  * Macros to help return an API entrypoint.
@@ -881,11 +938,21 @@
                        EGLNativeWindowType window, const EGLint *attrib_list)
 {
    _EGLDisplay *disp = _eglLockDisplay(dpy);
+   EGLSurface window_surface = NULL;
 
    _EGL_FUNC_START(disp, EGL_OBJECT_DISPLAY_KHR, NULL, EGL_NO_SURFACE);
    STATIC_ASSERT(sizeof(void*) == sizeof(window));
-   return _eglCreateWindowSurfaceCommon(disp, config, (void*) window,
-                                        attrib_list);
+
+   if (is_window_associated_with_surface(window))
+      RETURN_EGL_ERROR(disp, EGL_BAD_ALLOC, EGL_NO_SURFACE);
+
+   window_surface = _eglCreateWindowSurfaceCommon(disp, config, (void*)window,
+                                                  attrib_list);
+
+   if (window_surface)
+       associate_window_with_surface_list(window, window_surface);
+
+   return window_surface;
 }
 
 static void *
@@ -1076,6 +1143,8 @@
    _eglUnlinkSurface(surf);
    ret = drv->API.DestroySurface(drv, disp, surf);
 
+   disassociate_window_with_surface_list(surface);
+
    RETURN_EGL_EVAL(disp, ret);
 }
 
diff -x .git -x .gitignore -Naur mesa/src/gbm/backends/dri/gbm_dri.c isg_gms-mesa/src/gbm/backends/dri/gbm_dri.c
--- mesa/src/gbm/backends/dri/gbm_dri.c	2017-02-01 02:09:24.501831254 +0800
+++ isg_gms-mesa/src/gbm/backends/dri/gbm_dri.c	2017-02-01 02:06:01.554095157 +0800
@@ -678,8 +678,6 @@
          return NULL;
       }
 
-      image = dri->image->dupImage(wb->driver_buffer, NULL);
-
       switch (wb->format) {
       case WL_DRM_FORMAT_XRGB8888:
          gbm_format = GBM_FORMAT_XRGB8888;
@@ -696,6 +694,8 @@
       default:
          return NULL;
       }
+
+      image = dri->image->dupImage(wb->driver_buffer, NULL);
       break;
    }
 #endif
diff -x .git -x .gitignore -Naur mesa/src/glx/glxcmds.c isg_gms-mesa/src/glx/glxcmds.c
--- mesa/src/glx/glxcmds.c	2017-02-01 02:09:24.505831328 +0800
+++ isg_gms-mesa/src/glx/glxcmds.c	2017-02-01 02:06:01.558095231 +0800
@@ -1746,7 +1746,7 @@
    CARD32 *interval_ptr;
    CARD8 opcode;
 
-   if (gc == &dummyContext) {
+   if (gc == NULL || gc == &dummyContext) {
       return GLX_BAD_CONTEXT;
    }
 
diff -x .git -x .gitignore -Naur mesa/src/glx/query_renderer.c isg_gms-mesa/src/glx/query_renderer.c
--- mesa/src/glx/query_renderer.c	2017-02-01 02:09:23.893820055 +0800
+++ isg_gms-mesa/src/glx/query_renderer.c	2017-02-01 02:06:01.562095304 +0800
@@ -106,7 +106,7 @@
 {
    struct glx_context *gc = __glXGetCurrentContext();
 
-   if (gc == &dummyContext)
+   if (gc == NULL || gc == &dummyContext)
       return False;
 
    return __glXQueryRendererInteger(gc->psc, attribute, value);
@@ -166,7 +166,7 @@
 {
    struct glx_context *gc = __glXGetCurrentContext();
 
-   if (gc == &dummyContext)
+   if (gc == NULL || gc == &dummyContext)
       return False;
 
    return __glXQueryRendererString(gc->psc, attribute);
diff -x .git -x .gitignore -Naur mesa/src/glx/xfont.c isg_gms-mesa/src/glx/xfont.c
--- mesa/src/glx/xfont.c	2017-02-01 02:09:23.893820055 +0800
+++ isg_gms-mesa/src/glx/xfont.c	2017-02-01 02:06:01.566095379 +0800
@@ -235,7 +235,7 @@
    int i;
 
    dpy = CC->currentDpy;
-   win = CC->currentDrawable;
+   win = DefaultRootWindow(dpy);
 
 #if !defined(GLX_USE_APPLEGL)
    glxdraw = GetGLXDRIDrawable(CC->currentDpy, CC->currentDrawable);
diff -x .git -x .gitignore -Naur mesa/src/mapi/mapi_abi.py isg_gms-mesa/src/mapi/mapi_abi.py
--- mesa/src/mapi/mapi_abi.py	2017-02-01 02:09:23.941820938 +0800
+++ isg_gms-mesa/src/mapi/mapi_abi.py	2017-02-01 02:06:01.610096187 +0800
@@ -38,7 +38,7 @@
 
 
 # number of dynamic entries
-ABI_NUM_DYNAMIC_ENTRIES = 256
+ABI_NUM_DYNAMIC_ENTRIES = 512
 
 class ABIEntry(object):
     """Represent an ABI entry."""
diff -x .git -x .gitignore -Naur mesa/src/mapi/u_execmem.c isg_gms-mesa/src/mapi/u_execmem.c
--- mesa/src/mapi/u_execmem.c	2017-02-01 02:09:23.941820938 +0800
+++ isg_gms-mesa/src/mapi/u_execmem.c	2017-02-01 02:06:01.610096187 +0800
@@ -37,7 +37,7 @@
 #include "u_execmem.h"
 
 
-#define EXEC_MAP_SIZE (4*1024)
+#define EXEC_MAP_SIZE (8*1024)
 
 static mtx_t exec_mutex = _MTX_INITIALIZER_NP;
 

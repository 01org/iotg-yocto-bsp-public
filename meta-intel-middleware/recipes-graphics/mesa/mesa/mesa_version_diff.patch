diff -x .git -x .gitignore -Naur mesa/gms-integration isg_gms-mesa/gms-integration
--- mesa/gms-integration	1970-01-01 07:30:00.000000000 +0730
+++ isg_gms-mesa/gms-integration	2017-05-18 04:50:53.371723540 +0800
@@ -0,0 +1,7 @@
+###
+### GMS integration
+###
+upstream 3b782f6bc405971e70a090be90a2899bb6d751fc
+	clover: Work around build failure with AltiVec.
+topic/vpg_ufo_patches f20763b130512199822e9fdebf21fad8337bca85
+	egl: Fix for memleak in window-surface association list v4
diff -x .git -x .gitignore -Naur mesa/src/egl/drivers/dri2/egl_dri2.c isg_gms-mesa/src/egl/drivers/dri2/egl_dri2.c
--- mesa/src/egl/drivers/dri2/egl_dri2.c	2017-05-18 04:54:43.648194439 +0800
+++ isg_gms-mesa/src/egl/drivers/dri2/egl_dri2.c	2017-05-18 04:50:53.511726258 +0800
@@ -226,15 +226,6 @@
          dri_masks[3] = value;
          break;
 
-      case __DRI_ATTRIB_ACCUM_RED_SIZE:
-      case __DRI_ATTRIB_ACCUM_GREEN_SIZE:
-      case __DRI_ATTRIB_ACCUM_BLUE_SIZE:
-      case __DRI_ATTRIB_ACCUM_ALPHA_SIZE:
-         /* Don't expose visuals with the accumulation buffer. */
-         if (value > 0)
-            return NULL;
-         break;
-
       case __DRI_ATTRIB_FRAMEBUFFER_SRGB_CAPABLE:
          srgb = value != 0;
          if (!disp->Extensions.KHR_gl_colorspace && srgb)
@@ -1291,6 +1282,10 @@
    if (!dri2_dpy)
       return _eglError(EGL_NOT_INITIALIZED, "eglMakeCurrent");
 
+   /* check display */
+   if (!dri2_dpy)
+      return _eglError(EGL_BAD_DISPLAY, "eglMakeCurrent");
+
    /* make new bindings */
    if (!_eglBindContext(ctx, dsurf, rsurf, &old_ctx, &old_dsurf, &old_rsurf)) {
       /* _eglBindContext already sets the EGL error (in _eglCheckMakeCurrent) */
diff -x .git -x .gitignore -Naur mesa/src/egl/drivers/dri2/egl_dri2_fallbacks.h isg_gms-mesa/src/egl/drivers/dri2/egl_dri2_fallbacks.h
--- mesa/src/egl/drivers/dri2/egl_dri2_fallbacks.h	2017-05-18 04:54:43.652194517 +0800
+++ isg_gms-mesa/src/egl/drivers/dri2/egl_dri2_fallbacks.h	2017-05-18 04:50:53.511726258 +0800
@@ -37,11 +37,16 @@
    return NULL;
 }
 
+/*
+ * If config doesn't support pbuffer, there is a need to set egl error.
+ * EGL1.4 spec #3.5.2 - EGL_BAD_MATCH
+ */
 static inline _EGLSurface *
 dri2_fallback_create_pbuffer_surface(_EGLDriver *drv, _EGLDisplay *disp,
                                      _EGLConfig *conf,
                                      const EGLint *attrib_list)
 {
+   _eglError(EGL_BAD_MATCH, "dri2_fallback_create_pbuffer_surface");
    return NULL;
 }
 
diff -x .git -x .gitignore -Naur mesa/src/egl/drivers/dri2/platform_wayland.c isg_gms-mesa/src/egl/drivers/dri2/platform_wayland.c
--- mesa/src/egl/drivers/dri2/platform_wayland.c	2017-05-18 04:54:43.652194517 +0800
+++ isg_gms-mesa/src/egl/drivers/dri2/platform_wayland.c	2017-05-18 04:50:53.511726258 +0800
@@ -44,6 +44,7 @@
 
 #include <wayland-client.h>
 #include "wayland-drm-client-protocol.h"
+#include "wayland-egl-priv.h"
 
 enum wl_drm_format_flags {
    HAS_ARGB8888 = 1,
@@ -168,8 +169,8 @@
    dri2_surf->wl_win->resize_callback = resize_callback;
    dri2_surf->wl_win->destroy_window_callback = destroy_window_callback;
 
-   dri2_surf->base.Width =  -1;
-   dri2_surf->base.Height = -1;
+   dri2_surf->base.Width = window->width;
+   dri2_surf->base.Height = window->height;
 
    config = dri2_get_dri_config(dri2_conf, EGL_WINDOW_BIT,
                                 dri2_surf->base.GLColorspace);
diff -x .git -x .gitignore -Naur mesa/src/egl/drivers/dri2/platform_x11.c isg_gms-mesa/src/egl/drivers/dri2/platform_x11.c
--- mesa/src/egl/drivers/dri2/platform_x11.c	2017-05-18 04:54:43.652194517 +0800
+++ isg_gms-mesa/src/egl/drivers/dri2/platform_x11.c	2017-05-18 04:50:53.511726258 +0800
@@ -235,6 +235,16 @@
          goto cleanup_surf;
       }
 
+      /*
+       * WA for EGL to avoid attempts to create surface with 0 width or height.
+       * Mainly for eglCreatePbufferSurface, which creation with 0 width or
+       * height causes XServer unstable.
+       */
+      if (dri2_surf->base.Width == 0)
+          dri2_surf->base.Width = 1;
+      if (dri2_surf->base.Height == 0)
+          dri2_surf->base.Height = 1;
+
       dri2_surf->drawable = xcb_generate_id(dri2_dpy->conn);
       xcb_create_pixmap(dri2_dpy->conn, conf->BufferSize,
                        dri2_surf->drawable, screen->root,
@@ -389,7 +399,11 @@
    (*dri2_dpy->core->destroyDrawable)(dri2_surf->dri_drawable);
    
    if (dri2_dpy->dri2) {
-      xcb_dri2_destroy_drawable (dri2_dpy->conn, dri2_surf->drawable);
+       xcb_void_cookie_t cookie = xcb_dri2_destroy_drawable_checked(dri2_dpy->conn, dri2_surf->drawable);
+       xcb_generic_error_t* error = xcb_request_check(dri2_dpy->conn, cookie);
+       /* Possible adding error handling here. Currently errors are checked here (but ignored) to prevent process termination
+        if native window was already destroyed. */
+       free(error);
    } else {
       assert(dri2_dpy->swrast);
       swrastDestroyDrawable(dri2_dpy, dri2_surf);
@@ -887,6 +901,25 @@
    struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);
    struct dri2_egl_surface *dri2_surf = dri2_egl_surface(draw);
 
+   /*
+    * Updating surface width and height fields for querying size by
+    * eglQuerySurface with EGL_WIDTH, EGL_HEIGHT It's needed for window surface
+    * when window is resized.
+    */
+   if (!(draw->Type & EGL_PBUFFER_BIT)) {
+      xcb_generic_error_t *error = NULL;
+      xcb_get_geometry_cookie_t cookie = xcb_get_geometry (dri2_dpy->conn, dri2_surf->drawable);
+      xcb_get_geometry_reply_t *reply = xcb_get_geometry_reply (dri2_dpy->conn, cookie, &error);
+      if (reply != NULL)
+      {
+         dri2_surf->base.Width = reply->width;
+         dri2_surf->base.Height = reply->height;
+         free(reply);
+      }
+      if (error != NULL)
+        free(error);
+   }
+
    if (dri2_dpy->dri2) {
       if (dri2_x11_swap_buffers_msc(drv, disp, draw, 0, 0, 0) != -1) {
           return EGL_TRUE;
diff -x .git -x .gitignore -Naur mesa/src/egl/main/eglapi.c isg_gms-mesa/src/egl/main/eglapi.c
--- mesa/src/egl/main/eglapi.c	2017-05-18 04:54:43.652194517 +0800
+++ isg_gms-mesa/src/egl/main/eglapi.c	2017-05-18 04:50:53.511726258 +0800
@@ -90,6 +90,7 @@
 #include "c11/threads.h"
 #include "GL/mesa_glinterop.h"
 #include "eglcompiler.h"
+#include "util/list.h"
 
 #include "eglglobals.h"
 #include "eglcontext.h"
@@ -102,6 +103,72 @@
 #include "eglimage.h"
 #include "eglsync.h"
 
+/**
+ * List item containing window related to surface
+ */
+struct window_list_item
+{
+    struct list_head link;
+
+    EGLNativeWindowType native_window;
+    EGLSurface attached_surface;
+    EGLDisplay attached_display;
+};
+
+struct list_head window_list = {NULL, NULL};
+
+/*
+ * Checks if a EGLWindow already have a created surface.
+ */
+static inline bool
+is_window_associated_with_surface(EGLNativeWindowType window)
+{
+   list_for_each_entry(struct window_list_item, item, &window_list, link) {
+      if (item->native_window == window) {
+         return true;
+      }
+   }
+
+   return false;
+}
+
+static inline void
+associate_window_with_surface_list(EGLNativeWindowType window, EGLSurface surface,
+                                   EGLDisplay display)
+{
+   struct window_list_item *attach = malloc(sizeof(struct window_list_item));
+   assert(attach);
+
+   attach->native_window = window;
+   attach->attached_surface = surface;
+   attach->attached_display = display;
+
+   list_add(&attach->link, &window_list);
+}
+
+static inline void
+disassociate_window_with_surface_list(EGLSurface surface)
+{
+   list_for_each_entry(struct window_list_item, item, &window_list, link) {
+     if (item->attached_surface == surface) {
+       list_del(&item->link);
+       free(item);
+       break;
+     }
+   }
+}
+
+static inline void
+disassociate_all_window_surface_links_by_display(EGLDisplay display)
+{
+   list_for_each_entry_safe(struct window_list_item, item, &window_list, link) {
+      if (item->attached_display == display) {
+
+         list_del(&item->link);
+         free(item);
+      }
+   }
+}
 
 /**
  * Macros to help return an API entrypoint.
@@ -610,6 +677,10 @@
       *minor = disp->Version % 10;
    }
 
+   if (!window_list.next || !window_list.prev) {
+      list_inithead(&window_list);
+   }
+
    RETURN_EGL_SUCCESS(disp, EGL_TRUE);
 }
 
@@ -627,6 +698,13 @@
    if (disp->Initialized) {
       _EGLDriver *drv = disp->Driver;
 
+      /*
+       * Avoid mem leaks from window_surface_association_list
+       * when not on all window surfaces eglDestroySurface was called
+       * before calling eglTerminate.
+       */
+      disassociate_all_window_surface_links_by_display(dpy);
+
       drv->API.Terminate(drv, disp);
       /* do not reset disp->Driver */
       disp->ClientAPIsString[0] = 0;
@@ -884,11 +962,21 @@
                        EGLNativeWindowType window, const EGLint *attrib_list)
 {
    _EGLDisplay *disp = _eglLockDisplay(dpy);
+   EGLSurface window_surface = NULL;
 
    _EGL_FUNC_START(disp, EGL_OBJECT_DISPLAY_KHR, NULL, EGL_NO_SURFACE);
    STATIC_ASSERT(sizeof(void*) == sizeof(window));
-   return _eglCreateWindowSurfaceCommon(disp, config, (void*) window,
-                                        attrib_list);
+
+   if (is_window_associated_with_surface(window))
+      RETURN_EGL_ERROR(disp, EGL_BAD_ALLOC, EGL_NO_SURFACE);
+
+   window_surface = _eglCreateWindowSurfaceCommon(disp, config, (void*)window,
+                                                  attrib_list);
+
+   if (window_surface)
+       associate_window_with_surface_list(window, window_surface, dpy);
+
+   return window_surface;
 }
 
 static void *
@@ -1086,6 +1174,8 @@
    _eglUnlinkSurface(surf);
    ret = drv->API.DestroySurface(drv, disp, surf);
 
+   disassociate_window_with_surface_list(surface);
+
    RETURN_EGL_EVAL(disp, ret);
 }
 
diff -x .git -x .gitignore -Naur mesa/src/gbm/backends/dri/gbm_dri.c isg_gms-mesa/src/gbm/backends/dri/gbm_dri.c
--- mesa/src/gbm/backends/dri/gbm_dri.c	2017-05-18 04:54:44.152204226 +0800
+++ isg_gms-mesa/src/gbm/backends/dri/gbm_dri.c	2017-05-18 04:50:53.815732159 +0800
@@ -678,8 +678,6 @@
          return NULL;
       }
 
-      image = dri->image->dupImage(wb->driver_buffer, NULL);
-
       switch (wb->format) {
       case WL_DRM_FORMAT_XRGB8888:
          gbm_format = GBM_FORMAT_XRGB8888;
@@ -696,6 +694,8 @@
       default:
          return NULL;
       }
+
+      image = dri->image->dupImage(wb->driver_buffer, NULL);
       break;
    }
 #endif
diff -x .git -x .gitignore -Naur mesa/src/glx/glxcmds.c isg_gms-mesa/src/glx/glxcmds.c
--- mesa/src/glx/glxcmds.c	2017-05-18 04:54:44.168204537 +0800
+++ isg_gms-mesa/src/glx/glxcmds.c	2017-05-18 04:50:53.819732237 +0800
@@ -1746,7 +1746,7 @@
    CARD32 *interval_ptr;
    CARD8 opcode;
 
-   if (gc == &dummyContext) {
+   if (gc == NULL || gc == &dummyContext) {
       return GLX_BAD_CONTEXT;
    }
 
diff -x .git -x .gitignore -Naur mesa/src/glx/query_renderer.c isg_gms-mesa/src/glx/query_renderer.c
--- mesa/src/glx/query_renderer.c	2017-05-18 04:54:42.484171837 +0800
+++ isg_gms-mesa/src/glx/query_renderer.c	2017-05-18 04:50:53.823732315 +0800
@@ -106,7 +106,7 @@
 {
    struct glx_context *gc = __glXGetCurrentContext();
 
-   if (gc == &dummyContext)
+   if (gc == NULL || gc == &dummyContext)
       return False;
 
    return __glXQueryRendererInteger(gc->psc, attribute, value);
@@ -166,7 +166,7 @@
 {
    struct glx_context *gc = __glXGetCurrentContext();
 
-   if (gc == &dummyContext)
+   if (gc == NULL || gc == &dummyContext)
       return False;
 
    return __glXQueryRendererString(gc->psc, attribute);
diff -x .git -x .gitignore -Naur mesa/src/glx/xfont.c isg_gms-mesa/src/glx/xfont.c
--- mesa/src/glx/xfont.c	2017-05-18 04:54:42.488171914 +0800
+++ isg_gms-mesa/src/glx/xfont.c	2017-05-18 04:50:53.827732393 +0800
@@ -235,7 +235,7 @@
    int i;
 
    dpy = CC->currentDpy;
-   win = CC->currentDrawable;
+   win = DefaultRootWindow(dpy);
 
 #if !defined(GLX_USE_APPLEGL)
    glxdraw = GetGLXDRIDrawable(CC->currentDpy, CC->currentDrawable);
diff -x .git -x .gitignore -Naur mesa/src/mapi/mapi_abi.py isg_gms-mesa/src/mapi/mapi_abi.py
--- mesa/src/mapi/mapi_abi.py	2017-05-18 04:54:44.340207876 +0800
+++ isg_gms-mesa/src/mapi/mapi_abi.py	2017-05-18 04:50:53.871733246 +0800
@@ -38,7 +38,7 @@
 
 
 # number of dynamic entries
-ABI_NUM_DYNAMIC_ENTRIES = 256
+ABI_NUM_DYNAMIC_ENTRIES = 512
 
 class ABIEntry(object):
     """Represent an ABI entry."""
diff -x .git -x .gitignore -Naur mesa/src/mapi/u_execmem.c isg_gms-mesa/src/mapi/u_execmem.c
--- mesa/src/mapi/u_execmem.c	2017-05-18 04:54:42.556173235 +0800
+++ isg_gms-mesa/src/mapi/u_execmem.c	2017-05-18 04:50:53.871733246 +0800
@@ -37,7 +37,7 @@
 #include "u_execmem.h"
 
 
-#define EXEC_MAP_SIZE (4*1024)
+#define EXEC_MAP_SIZE (8*1024)
 
 static mtx_t exec_mutex = _MTX_INITIALIZER_NP;
 

From ddad7dc821d3a15d3f926e273a0818130f56a882 Mon Sep 17 00:00:00 2001
From: Owen Zhang <owen.zhang@intel.com>
Date: Thu, 8 Jun 2017 15:47:02 +0800
Subject: [PATCH 10/14] intel: add the new bo emit reloc2 for bo offset

with this new interface, the KMD will reloc BO when the offset mismatch.

Signed-off-by: Owen Zhang <owen.zhang@intel.com>
Signed-off-by: Matt Roper <matthew.d.roper@intel.com>
---
 intel/intel_bufmgr.c      | 12 +++++++
 intel/intel_bufmgr.h      |  4 +++
 intel/intel_bufmgr_gem.c  | 92 +++++++++++++++++++++++++++++++++++++++++++++++
 intel/intel_bufmgr_priv.h |  4 +++
 4 files changed, 112 insertions(+)

diff --git a/intel/intel_bufmgr.c b/intel/intel_bufmgr.c
index 192de09..1033cfb 100644
--- a/intel/intel_bufmgr.c
+++ b/intel/intel_bufmgr.c
@@ -196,6 +196,18 @@ drm_intel_bo_flink(drm_intel_bo *bo, uint32_t * name)
 }
 
 int
+drm_intel_bo_emit_reloc2(drm_intel_bo *bo, uint32_t offset,
+			drm_intel_bo *target_bo, uint32_t target_offset,
+			uint32_t read_domains, uint32_t write_domain,
+			uint64_t presumed_offset)
+{
+	return bo->bufmgr->bo_emit_reloc2(bo, offset,
+					 target_bo, target_offset,
+					 read_domains, write_domain,
+					 presumed_offset);
+}
+
+int
 drm_intel_bo_emit_reloc(drm_intel_bo *bo, uint32_t offset,
 			drm_intel_bo *target_bo, uint32_t target_offset,
 			uint32_t read_domains, uint32_t write_domain)
diff --git a/intel/intel_bufmgr.h b/intel/intel_bufmgr.h
index 50483af..38068d6 100644
--- a/intel/intel_bufmgr.h
+++ b/intel/intel_bufmgr.h
@@ -151,6 +151,10 @@ int drm_intel_bufmgr_check_aperture_space(drm_intel_bo ** bo_array, int count);
 int drm_intel_bo_emit_reloc(drm_intel_bo *bo, uint32_t offset,
 			    drm_intel_bo *target_bo, uint32_t target_offset,
 			    uint32_t read_domains, uint32_t write_domain);
+int drm_intel_bo_emit_reloc2(drm_intel_bo *bo, uint32_t offset,
+		 drm_intel_bo *target_bo, uint32_t target_offset,
+		 uint32_t read_domains, uint32_t write_domain,
+		 uint64_t presumed_offset);
 int drm_intel_bo_emit_reloc_fence(drm_intel_bo *bo, uint32_t offset,
 				  drm_intel_bo *target_bo,
 				  uint32_t target_offset,
diff --git a/intel/intel_bufmgr_gem.c b/intel/intel_bufmgr_gem.c
index 730f425..f1bc491 100644
--- a/intel/intel_bufmgr_gem.c
+++ b/intel/intel_bufmgr_gem.c
@@ -2167,6 +2167,83 @@ do_bo_emit_reloc(drm_intel_bo *bo, uint32_t offset,
 	return 0;
 }
 
+static int
+do_bo_emit_reloc2(drm_intel_bo *bo, uint32_t offset,
+		 drm_intel_bo *target_bo, uint32_t target_offset,
+		 uint32_t read_domains, uint32_t write_domain,
+		 bool need_fence, uint64_t presumed_offset)
+{
+	drm_intel_bufmgr_gem *bufmgr_gem = (drm_intel_bufmgr_gem *) bo->bufmgr;
+	drm_intel_bo_gem *bo_gem = (drm_intel_bo_gem *) bo;
+	drm_intel_bo_gem *target_bo_gem = (drm_intel_bo_gem *) target_bo;
+	bool fenced_command;
+
+	if (bo_gem->has_error)
+		return -ENOMEM;
+
+	if (target_bo_gem->has_error) {
+		bo_gem->has_error = true;
+		return -ENOMEM;
+	}
+
+	/* We never use HW fences for rendering on 965+ */
+	if (bufmgr_gem->gen >= 4)
+		need_fence = false;
+
+	fenced_command = need_fence;
+	if (target_bo_gem->tiling_mode == I915_TILING_NONE)
+		need_fence = false;
+
+	/* Create a new relocation list if needed */
+	if (bo_gem->relocs == NULL && drm_intel_setup_reloc_list(bo))
+		return -ENOMEM;
+
+	/* Check overflow */
+	assert(bo_gem->reloc_count < bufmgr_gem->max_relocs);
+
+	/* Check args */
+	assert(offset <= bo->size - 4);
+	assert((write_domain & (write_domain - 1)) == 0);
+
+	/* An object needing a fence is a tiled buffer, so it won't have
+	 * relocs to other buffers.
+	 */
+	if (need_fence) {
+		assert(target_bo_gem->reloc_count == 0);
+		target_bo_gem->reloc_tree_fences = 1;
+	}
+
+	/* Make sure that we're not adding a reloc to something whose size has
+	 * already been accounted for.
+	 */
+	assert(!bo_gem->used_as_reloc_target);
+	if (target_bo_gem != bo_gem) {
+		target_bo_gem->used_as_reloc_target = true;
+		bo_gem->reloc_tree_size += target_bo_gem->reloc_tree_size;
+		bo_gem->reloc_tree_fences += target_bo_gem->reloc_tree_fences;
+	}
+
+	bo_gem->reloc_target_info[bo_gem->reloc_count].bo = target_bo;
+	if (target_bo != bo)
+		drm_intel_gem_bo_reference(target_bo);
+	if (fenced_command)
+		bo_gem->reloc_target_info[bo_gem->reloc_count].flags =
+			DRM_INTEL_RELOC_FENCE;
+	else
+		bo_gem->reloc_target_info[bo_gem->reloc_count].flags = 0;
+
+	bo_gem->relocs[bo_gem->reloc_count].offset = offset;
+	bo_gem->relocs[bo_gem->reloc_count].delta = target_offset;
+	bo_gem->relocs[bo_gem->reloc_count].target_handle =
+	    target_bo_gem->gem_handle;
+	bo_gem->relocs[bo_gem->reloc_count].read_domains = read_domains;
+	bo_gem->relocs[bo_gem->reloc_count].write_domain = write_domain;
+	bo_gem->relocs[bo_gem->reloc_count].presumed_offset = presumed_offset;
+	bo_gem->reloc_count++;
+
+	return 0;
+}
+
 static void
 drm_intel_gem_bo_use_48b_address_range(drm_intel_bo *bo, uint32_t enable)
 {
@@ -2233,6 +2310,20 @@ drm_intel_gem_bo_emit_reloc(drm_intel_bo *bo, uint32_t offset,
 }
 
 static int
+drm_intel_gem_bo_emit_reloc2(drm_intel_bo *bo, uint32_t offset,
+			    drm_intel_bo *target_bo, uint32_t target_offset,
+			    uint32_t read_domains, uint32_t write_domain,
+			    uint64_t presumed_offset)
+{
+	drm_intel_bufmgr_gem *bufmgr_gem = (drm_intel_bufmgr_gem *)bo->bufmgr;
+
+	return do_bo_emit_reloc2(bo, offset, target_bo, target_offset,
+					read_domains, write_domain,
+					!bufmgr_gem->fenced_relocs,
+					presumed_offset);
+}
+
+static int
 drm_intel_gem_bo_emit_reloc_fence(drm_intel_bo *bo, uint32_t offset,
 				  drm_intel_bo *target_bo,
 				  uint32_t target_offset,
@@ -3928,6 +4019,7 @@ drm_intel_bufmgr_gem_init(int fd, int batch_size)
 	bufmgr_gem->bufmgr.bo_get_subdata = drm_intel_gem_bo_get_subdata;
 	bufmgr_gem->bufmgr.bo_wait_rendering = drm_intel_gem_bo_wait_rendering;
 	bufmgr_gem->bufmgr.bo_emit_reloc = drm_intel_gem_bo_emit_reloc;
+	bufmgr_gem->bufmgr.bo_emit_reloc2 = drm_intel_gem_bo_emit_reloc2;
 	bufmgr_gem->bufmgr.bo_emit_reloc_fence = drm_intel_gem_bo_emit_reloc_fence;
 	bufmgr_gem->bufmgr.bo_pin = drm_intel_gem_bo_pin;
 	bufmgr_gem->bufmgr.bo_unpin = drm_intel_gem_bo_unpin;
diff --git a/intel/intel_bufmgr_priv.h b/intel/intel_bufmgr_priv.h
index 7e360a0..1103d98 100644
--- a/intel/intel_bufmgr_priv.h
+++ b/intel/intel_bufmgr_priv.h
@@ -188,6 +188,10 @@ struct _drm_intel_bufmgr {
 	int (*bo_emit_reloc) (drm_intel_bo *bo, uint32_t offset,
 			      drm_intel_bo *target_bo, uint32_t target_offset,
 			      uint32_t read_domains, uint32_t write_domain);
+	int (*bo_emit_reloc2) (drm_intel_bo *bo, uint32_t offset,
+			      drm_intel_bo *target_bo, uint32_t target_offset,
+			      uint32_t read_domains, uint32_t write_domain,
+			      uint64_t presumed_offset);
 	int (*bo_emit_reloc_fence)(drm_intel_bo *bo, uint32_t offset,
 				   drm_intel_bo *target_bo,
 				   uint32_t target_offset,
-- 
1.9.1

